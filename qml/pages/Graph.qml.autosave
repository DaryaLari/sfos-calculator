import QtQuick 2.0
import Sailfish.Silica 1.0
import "d3.js" as D3
import "../assets"

Page {

    property var elem:[7,0,1,0,0]
    property var border:[[-10,-10],[+10,+10]];

    property int rootLine:0
    id: page

    // The effective value will be restricted by ApplicationWindow.allowedOrientations
    allowedOrientations: Orientation.All
//basic
    Canvas {
        anchors.margins: Theme.horizontalPageMargin

        id:plot
        property real minX: -width / 2
        property real maxX: width / 2
        property real minY: -height / 2
        property real maxY: height / 2

        property int leftMargin: 10
        property int bottomMargin: 10
        width: parent.width
        height: parent.height
      // Определение различных свойств

        //graph drawer
      onPaint:{
          var context = plot.getContext('2d');
          context.clearRect(0,0,plot.width,plot.height);

          var xOffset = (border[1][0] - border[0][0]) / 10;
          var yOffset = (border[1][1] - border[0][1]) / 10;
          minX = border[0][0] - xOffset;
          maxX = border[1][0] + xOffset;
          minY = border[0][1] - yOffset;
          maxY = border[1][1] + yOffset;

          //scale X, d3.scaleLinear, which simplify work with scaling of the chart
          var xScale = d3.scaleLinear()
            .range([0, width])
          .domain([minX, maxX]);



          //scales Y, d3.scaleLinear, which simplify work with scaling of the chart
               var yScale = d3.scaleLinear()
          .range([height - bottomMargin, 0])
          .domain([minY, maxY]);

          var line = x(xScale, yScale, context);


//          var line = d3.line().x(function (d) {
//              return xScale(d[0]);
//            }).y(function (d) {
//              return yScale(d[1]);
//            }).curve(d3.curveNatural).context(context);

          //properties of graph
          context.beginPath();
          context.lineWidth = 1.5;
          context.strokeStyle = "white";
          context.fillStyle = "white";

          drawXAxis(context, 5);
          drawYAxis(context, 10);
          line([[minX, rootLine], [maxX, rootLine]]);
          line([[rootLine, minY], [rootLine, maxY]]);
          drawPlot(line);

          context.stroke();
      }
      function x(xScale, yScale, context) {
          return d3.line().x(function (d) {
              return xScale(d[0]);
          }).y(function (d) {
              return yScale(d[1]);
          }).curve(d3.curveNatural)
          .context(context);
      }

      function drawXAxis(context, steps) {
          var yScale = d3.scaleLinear().range([0, height]).domain([height, 0]);
          var line = x(d3.scaleLinear().range([0, width]).domain([0, width]), yScale, context);
          line([[leftMargin, bottomMargin], [width, bottomMargin]]);
          context.font = '20px serif';
          var stepSize = (width - leftMargin) / steps;
          var plotStepSize = (maxX - minX) / steps;
          for (var i = 1; i < steps; i++) {
              line([[stepSize * i + leftMargin, bottomMargin],
                    [stepSize * i + leftMargin, bottomMargin + 20]])
              // Decimal points should be configured with dependency on max - min interval length
              var text = (minX + plotStepSize * i).toFixed(1).toString();
              context.fillText(text, stepSize * i + leftMargin -
                               context.measureText(text).width / 2, yScale(25 + bottomMargin));
          }
      }

      function drawYAxis(context, steps) {
          var yScale = d3.scaleLinear().range([0, height]).domain([height, 0]);
          var line = x(d3.scaleLinear().range([0, width]).domain([0, width]), yScale, context)
          line([[leftMargin, bottomMargin], [leftMargin, height - bottomMargin]]);
          context.font = '20px serif';
          var stepSize = (height - bottomMargin) / steps;
          var plotStepSize = (maxY - minY) / steps;
          for (var i = 1; i < steps; i++) {
              line([[leftMargin, stepSize * i + bottomMargin],
                    [leftMargin + 20, stepSize * i + bottomMargin]])
              // Decimal points should be configured with dependency on max - min interval length
              var text = (minY + plotStepSize * i).toFixed(1).toString();
              context.fillText(text, leftMargin + 25, yScale(stepSize * i + bottomMargin - 10));
          }
      }

      function changeZoomPlus(levelZoom){
          if( border[1][1] - levelZoom > 0 && border[1][0] - levelZoom  > 0 ){
              border[0][0]+=levelZoom;
              border[0][1]+=levelZoom;
              border[1][0]-=levelZoom;
              border[1][1]-=levelZoom;
          }
          plot.requestPaint();
      }

      function changeZoomMinus(levelZoom){
          border[0][0]-=levelZoom;
          border[0][1]-=levelZoom;
          border[1][0]+=levelZoom;
          border[1][1]+=levelZoom;
          plot.requestPaint();
      }

      function roundOfNum(num){
          return Math.round(num * 100) / 100;
      }
      function drawPlot(line) {
          line(getPoints());
      }

      function getPoints() {
          var points = [];
          var dx = (maxX - minX) / 100;
          for(var x = minX; x <= maxX; x += dx) {
              var y = 0;
              for (var j = 0; j < 5; j++) {
                  y += Math.pow(x, j)  * elem[j];
              }
              points.push([x, y]);
          }
          return points;
      }
      Item {
          id:zoom
          anchors.fill: plot
          //processing pinch gesture
        PinchArea{
            id: pinchArea
            property real minScale: 0.5
            property real maxScale: 1.0
            anchors.fill: parent
            pinch.target: zoom
            pinch.minimumScale: minScale * 0.5
            pinch.maximumScale: maxScale * 1.5
            //The commented code below - fire exit
            onPinchFinished: {
                ////                console.log(zoom.scale)
                ////                if (zoom.scale <= 1)
                ////                    plot.changeZoomPlus(Math.round(zoom.scale));
                ////                else
                ////                    plot.changeZoomMinus(Math.round(zoom.scale*10));
                zoom.scale = 1;
            }
            onPinchUpdated: {
                if (zoom.scale >= 1)
                    plot.changeZoomPlus(roundOfNum(zoom.scale));
                else
                    plot.changeZoomMinus(roundOfNum(zoom.scale));
            }

            Rectangle {
                opacity: 0.0
                anchors.fill: parent
            }
        }
        //processing moving
        MouseArea {
            id: inputArea
            anchors.fill: parent
            onPressed: {
                coordsOnPressed = [mouse.x,mouse.y];
            }
            onPositionChanged: {
                coordsOnReleased = [mouse.x,mouse.y];
                coordsOfMovement = [Math.round((coordsOnPressed[0]-coordsOnReleased[0])/100),Math.round((coordsOnReleased[1]-coordsOnPressed[1])/100)];
                border[0][0]+=coordsOfMovement[0];
                border[0][1]+=coordsOfMovement[1];
                border[1][0]+=coordsOfMovement[0];
                border[1][1]+=coordsOfMovement[1];
                coordsOnPressed =  coordsOnReleased
                plot.requestPaint();
            }
        }
      }
    }

   }
